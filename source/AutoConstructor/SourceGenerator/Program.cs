using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using AutoConstructor.Attributes;
using SourceGeneration.Helpers;
using SourceGeneration.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using SourceGeneration.Extensions;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace AutoConstructor.SourceGenerator;

/// <summary>
/// A source generator creating constructors for types annotated with <see cref="AutoConstructorAttribute"/>.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AutoConstructorGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var info = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                typeof(AutoConstructorAttribute).FullName!,
                static (s, _) => s is TypeDeclarationSyntax,
                static (context, _) => GetInfo(context))
            .Where(t => t is not null);

        // Generate the constructors
        context.RegisterSourceOutput(info, static (context, item) =>
        {
            var compilationUnit = GeneratePartialWithConstructor(item!);

            context.AddSource(
                item!.Hierarchy.FullyQualifiedMetadataName + ".AutoProps.g.cs",
                compilationUnit.GetText(Encoding.UTF8));
        });
    }

    internal record Info
    {
        public record struct Constructor
        {
            public required EquatableArray<MemberOrParameter> Parameters { get; init; }
        }
        public record struct MemberOrParameter
        {
            public required string Name { get; init; }
            public required TypeSyntaxReference Type { get; init; }
        }
        public record struct ConstructorsInfo
        {
            public required EquatableArray<Constructor>? Constructors { get; init; }
            public required Constructor? AutogeneratedConstructor { get; init; }
        }

        public required string Name { get; init; }
        public required EquatableArray<MemberOrParameter> MemberNamesToSet { get; init; }
        // Null if doesn't have a base type.
        public required ConstructorsInfo? BaseConstructors { get; init; }
        public required HierarchyInfo Hierarchy { get; init; }
    }

    private static Info? GetInfo(GeneratorAttributeSyntaxContext context)
    {
        var typeSymbol = (INamedTypeSymbol) context.TargetSymbol;
        if (typeSymbol.Constructors.Any(c => !c.IsImplicitlyDeclared))
            return null;

        var hierarchyInfo = HierarchyInfo.From(typeSymbol);
        var constructors = GetBaseConstructors(context.SemanticModel.Compilation, typeSymbol);
        var members = GetMembersToSet(typeSymbol).ToImmutableArray();

        return new Info
        {
            BaseConstructors = constructors,
            Hierarchy = hierarchyInfo,
            MemberNamesToSet = members,
            Name = typeSymbol.Name,
        };
    }

    private static IEnumerable<Info.MemberOrParameter> GetMembersToSet(ITypeSymbol typeSymbol)
    {
        foreach (var member in typeSymbol.GetMembers())
        {
            // Ignore parent symbols
            if (!member.ContainingType.Equals(typeSymbol, SymbolEqualityComparer.Default))
                continue;
            if (member is not IFieldSymbol field)
                continue;
            if (member.IsStatic)
                continue;

            ITypeSymbol type;
            string name;
            if (field.AssociatedSymbol is IPropertySymbol property)
            {
                if (property.DeclaredAccessibility == Accessibility.Public
                    && !field.IsReadOnly)
                {
                    continue;
                }

                name = property.Name;
                type = property.Type;
            }
            else
            {
                if (field.DeclaredAccessibility == Accessibility.Public
                    && !field.IsReadOnly)
                {
                    continue;
                }

                name = field.Name;
                type = field.Type;
            }

            var memberInfo = new Info.MemberOrParameter
            {
                Type = TypeSyntaxReference.From(type),
                Name = name,
            };
            yield return memberInfo;
        }
    }

    private static Info.ConstructorsInfo? GetBaseConstructors(
        Compilation compilation, INamedTypeSymbol typeSymbol)
    {
        if (typeSymbol.BaseType is not { } baseType)
            return null;

        bool isBaseConstructorAutogenerated = baseType.TryGetAttributeWithFullyQualifiedMetadataName(
            typeof(AutoConstructorAttribute).FullName!, out _);

        if (isBaseConstructorAutogenerated)
        {
            var parameters = GetAutogeneratedConstructorParameters(compilation, baseType);
            return new Info.ConstructorsInfo
            {
                Constructors = null,
                AutogeneratedConstructor = new()
                {
                    Parameters = parameters,
                },
            };
        }

        using var baseConstructors = ImmutableArrayBuilder<Info.Constructor>.Rent();
        foreach (var c in baseType.Constructors)
        {
            if (c.IsStatic)
                continue;
            if (c.IsImplicitlyDeclared)
                continue;
            if (!compilation.IsSymbolAccessibleWithin(c, typeSymbol))
                continue;

            using var parameters = ImmutableArrayBuilder<Info.MemberOrParameter>.Rent();
            foreach (var p in c.Parameters)
            {
                var type = TypeSyntaxReference.From(p.Type);
                parameters.Add(new Info.MemberOrParameter
                {
                    Name = p.Name,
                    Type = type,
                });
            }

            var resultParams = parameters.ToImmutable();
            baseConstructors.Add(new Info.Constructor
            {
                Parameters = resultParams,
            });
        }

        return new Info.ConstructorsInfo
        {
            Constructors = baseConstructors.ToImmutable(),
            AutogeneratedConstructor = null,
        };
    }

    private static CompilationUnitSyntax GeneratePartialWithConstructor(Info info)
    {
        var paramsToPassAlong = info.BaseConstructors is { } constructors
            ? GetBestBaseConstructorParameters(constructors)
            : ImmutableArray<Info.MemberOrParameter>.Empty;

        TypeSyntax GetTypeSyntax(TypeSyntaxReference type)
        {
            // NOTE: This is a special case for ILogger<T> and ILogger. Might generalize later.
            const string loggerPrefix = "global::Microsoft.Extensions.Logging.ILogger";
            bool isLogger = type.FullyQualifiedName.StartsWith(loggerPrefix);
            if (isLogger)
                return ParseTypeName($"{loggerPrefix}<{info.Hierarchy.Hierarchy[0].QualifiedName}>");

            return type.AsSyntax();
        }

        using var newParams = ListHelper.Rent<ParameterSyntax>(info.MemberNamesToSet.Length);
        foreach (var p in info.MemberNamesToSet)
        {
            var normalizedName = NormalizeName(p.Name);
            var parameter = Parameter(Identifier(normalizedName))
                .WithType(GetTypeSyntax(p.Type));
            newParams.Add(parameter);
        }

        using var memberAssignments = ListHelper.Rent<StatementSyntax>(newParams.Count);
        for (int i = 0; i < newParams.Count; i++)
        {
            var newParam = newParams[i];
            // this._a = @a
            var assignmentExpression = AssignmentExpression(
                SyntaxKind.SimpleAssignmentExpression,
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("this"),
                    IdentifierName(info.MemberNamesToSet[i].Name)),
                IdentifierName(newParam.Identifier));
            memberAssignments.Add(ExpressionStatement(assignmentExpression));
        }

        using var allParams = ListHelper.Rent<ParameterSyntax>(paramsToPassAlong.Length);
        foreach (var p in paramsToPassAlong)
        {
            var parameter = Parameter(Identifier(p.Name))
                .WithType(GetTypeSyntax(p.Type));
            allParams.Add(parameter);
        }
        allParams.AddRange(newParams.Enumerable);

        var constructorSyntax = ConstructorDeclaration(Identifier(info.Name))
            .WithParameterList(ParameterList(SeparatedList(allParams.Enumerable)))
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)));

        if (paramsToPassAlong.Length > 0)
        {
            using var arguments = ListHelper.Rent<ArgumentSyntax>(paramsToPassAlong.Length);
            foreach (var p in paramsToPassAlong)
            {
                var arg = Argument(IdentifierName(p.Name));
                arguments.Add(arg);
            }

            constructorSyntax = constructorSyntax
                .WithInitializer(ConstructorInitializer(
                    SyntaxKind.BaseConstructorInitializer, ArgumentList(SeparatedList(arguments.Enumerable))));
        }

        constructorSyntax = constructorSyntax.WithBody(Block(memberAssignments.Enumerable));
        return info.Hierarchy.GetSyntax(
            new MemberDeclarationSyntax[] { constructorSyntax },
            nullableEnable: true);
    }

    private static ImmutableArray<Info.MemberOrParameter> GetBestBaseConstructorParameters(
        Info.ConstructorsInfo constructors)
    {
        if (constructors.AutogeneratedConstructor is { } ag)
            return ag.Parameters;
        var cs = constructors.Constructors!.Value;
        if (cs.Length > 0)
            return cs.OrderByDescending(c => c.Parameters.Length).First().Parameters;
        return ImmutableArray<Info.MemberOrParameter>.Empty;
    }

    private static ImmutableArray<Info.MemberOrParameter> GetAutogeneratedConstructorParameters(
        Compilation compilation, INamedTypeSymbol baseType)
    {
        var maybeConstructors = GetBaseConstructors(compilation, baseType);
        var membersToSet = GetMembersToSet(baseType);
        using var parameters = ImmutableArrayBuilder<Info.MemberOrParameter>.Rent();
        if (maybeConstructors is { } constructors)
        {
            foreach (var member in GetBestBaseConstructorParameters(constructors))
                parameters.Add(member);
        }
        foreach (var member in membersToSet)
        {
            var m = member with { Name = NormalizeName(member.Name) };
            parameters.Add(m);
        }
        return parameters.ToImmutable();
    }

    private static string NormalizeName(string fieldOrPropertyName)
    {
        if (fieldOrPropertyName.Length == 0)
            return "";
        if (fieldOrPropertyName.StartsWith("_"))
        {
            if (fieldOrPropertyName.Length == 1)
                return fieldOrPropertyName;
            fieldOrPropertyName = fieldOrPropertyName[1..];
        }

        if (char.IsUpper(fieldOrPropertyName[0]))
            fieldOrPropertyName = char.ToUpper(fieldOrPropertyName[0]) + fieldOrPropertyName[1..];

        return "@" + fieldOrPropertyName;
    }
}

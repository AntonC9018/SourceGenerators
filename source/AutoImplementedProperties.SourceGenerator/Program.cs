using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using AutoImplementedProperties.Attributes;
using SourceGeneration.Helpers;
using SourceGeneration.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using NetStandard;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace AutoImplementedProperties.SourceGenerator;

public static class ShouldBeAutogened
{
    public readonly struct TypedGeneratorContext
    {
        public readonly INamedTypeSymbol TargetSymbol;
        public readonly TypeDeclarationSyntax TargetNode;
        public readonly SemanticModel SemanticModel;
        public readonly AutoImplementPropertiesAttribute Attribute;

        public TypedGeneratorContext(
            INamedTypeSymbol targetSymbol,
            TypeDeclarationSyntax targetNode,
            SemanticModel semanticModel,
            AutoImplementPropertiesAttribute attribute)
        {
            TargetSymbol = targetSymbol;
            TargetNode = targetNode;
            SemanticModel = semanticModel;
            Attribute = attribute;
        }
    }
    
    public static IncrementalValuesProvider<T> ForAutoImplementedAttribute<T>(
        this SyntaxValueProvider syntaxProvider,
        Func<TypedGeneratorContext, CancellationToken, T> valueFactory,
        Func<SyntaxNode, CancellationToken, bool>? additionalSyntaxFilter = null)
    {
        Func<SyntaxNode, CancellationToken, bool> filter;
        if (additionalSyntaxFilter == null)
            filter = (node, token) => node is TypeDeclarationSyntax;
        else
            filter = (node, token) => node is TypeDeclarationSyntax
                && additionalSyntaxFilter(node, token);
        
        return syntaxProvider.ForAttributeWithMetadataName(
            typeof(AutoImplementPropertiesAttribute).FullName,
            filter,
            (context, cancellationToken) =>
            {
                INamedTypeSymbol symbol = (INamedTypeSymbol)context.TargetSymbol;
                var attribute = GetAutoImplementPropertiesAttribute(context);
                var typedContext = new TypedGeneratorContext(
                    symbol,
                    (TypeDeclarationSyntax)context.TargetNode,
                    context.SemanticModel,
                    attribute);
                return valueFactory(typedContext, cancellationToken);
            });
    }
    
    // NOTE: should return an equivalent autogenerated type
    public static AutoImplementPropertiesAttribute GetAutoImplementPropertiesAttribute(
        this GeneratorAttributeSyntaxContext context)
    {
        var syntax = context.TargetNode as TypeDeclarationSyntax;
        return new AutoImplementPropertiesAttribute();
    }
}

internal record struct Info
{
    public record struct Property
    {
        public string TypeDisplayName { get; set; }
        public string Name { get; set; }
    }
    public record struct OverloadedProperty
    {
        public Property Property { get; set; }
        public string InterfaceNameForExplicitImpl { get; set; }
    }
    public bool HasPropertiesToImplement => PropertiesToImplement.Any()
        || OverloadedPropertiesToImplement.Any(); 
    public EquatableArray<Property> PropertiesToImplement { get; set; }
    public EquatableArray<OverloadedProperty> OverloadedPropertiesToImplement { get; set; }
    public HierarchyInfo Hierarchy { get; set; }
}

public static class Helper
{
    public static IEnumerable<ITypeSymbol> GetSelfAndSubtypes(this ITypeSymbol type)
    {
        yield return type;
        while (type.BaseType is { } baseType)
        {
            yield return baseType;
            type = baseType;
        }
    }

    public static IEnumerable<ISymbol> GetAllMembers(this ITypeSymbol type)
    {
        return type.GetSelfAndSubtypes()
            .SelectMany(t => t.GetMembers());
    }
}

/// <summary>
/// A source generator creating constructors for types annotated with <see cref="AutoConstructorAttribute"/>.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AutoConstructorGenerator : IIncrementalGenerator
{
    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<Info> constructorInfo = context.SyntaxProvider
            .ForAutoImplementedAttribute(static (context, _) => GetInfo(context))
            .Where(static info => info.HasPropertiesToImplement);

        // Generate the constructors
        context.RegisterSourceOutput(constructorInfo, static (context, item) =>
        {
            var compilationUnit = GeneratePartialImplementingUnimplementedMembers(item);
            context.AddSource(
                item.Hierarchy.FullyQualifiedMetadataName + ".AutoProps.g.cs",
                compilationUnit.GetText(Encoding.UTF8));
        });
    }
    
    private static Info GetInfo(ShouldBeAutogened.TypedGeneratorContext context)
    {
        var interfaceProperties = context.TargetSymbol
            .AllInterfaces
            .SelectMany(i => i.GetMembers().OfType<IPropertySymbol>())
            .Where(p => p.GetMethod is not null && p.SetMethod is not null);
        
        var interfacePropsSet = new HashSet<IPropertySymbol>(
            interfaceProperties, SymbolEqualityComparer.Default);

        var allProperties = context.TargetSymbol
            .GetAllMembers()
            .OfType<IPropertySymbol>();
        
        foreach (var p in allProperties)
        {
            if (p.GetMethod is null || p.SetMethod is null)
                continue;

            if (p is { ExplicitInterfaceImplementations: [{ } explicitImpl] })
            {
                interfacePropsSet.Remove(explicitImpl);
                continue;
            }

            interfacePropsSet.RemoveWhere(
                remainingProp => p.Name == remainingProp.Name);
        }

        var propsByName = interfacePropsSet
            .GroupBy(p => p.Name);

        using var propertiesToImplement = ImmutableArrayBuilder<Info.Property>.Rent();
        using var overloadedPropertiesToImplement = ImmutableArrayBuilder<Info.OverloadedProperty>.Rent();
        
        foreach (var group in propsByName)
        {
            using var enumerator = group.AsEnumerable().GetEnumerator();
            Debug.Assert(enumerator.MoveNext());

            Info.Property CreatePropInfo(IPropertySymbol p)
            {
                return new Info.Property
                {
                    Name = p.Name,
                    TypeDisplayName = p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                };
            }
            
            Info.OverloadedProperty CreateOverloadedPropInfo(IPropertySymbol p)
            {
                var info = CreatePropInfo(p);
                var info2 = new Info.OverloadedProperty
                {
                    Property = info,
                    InterfaceNameForExplicitImpl = p.ContainingType
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                };
                return info2;
            }
            
            var first = enumerator.Current!;
            if (enumerator.MoveNext() == false)
            {
                var info = CreatePropInfo(first); 
                propertiesToImplement.Add(info);
            }
            else
            {

                {
                    var info = CreateOverloadedPropInfo(first);
                    overloadedPropertiesToImplement.Add(info);
                }
                do
                {
                    var current = enumerator.Current!;
                    var info = CreateOverloadedPropInfo(current);
                    overloadedPropertiesToImplement.Add(info);
                }
                while (enumerator.MoveNext());
            }
        }

        var hierarchyInfo = HierarchyInfo.From(context.TargetSymbol);
        
        return new Info
        {
            PropertiesToImplement = propertiesToImplement.ToImmutable(),
            OverloadedPropertiesToImplement = overloadedPropertiesToImplement.ToImmutable(),
            Hierarchy = hierarchyInfo,
        };
    }

    private static CompilationUnitSyntax GeneratePartialImplementingUnimplementedMembers(Info info)
    {
        using var propertyDeclarations = ImmutableArrayBuilder<MemberDeclarationSyntax>.Rent();

        PropertyDeclarationSyntax CreateFromInfo(Info.Property p)
        {
            TypeSyntax type = IdentifierName(p.TypeDisplayName);
            SyntaxToken name = Identifier(p.Name);
            var propertyDeclaration = PropertyDeclaration(type, name)
                .WithAccessorList(AccessorList(List(new[]
                {
                    AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                    AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                        .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                })));
            return propertyDeclaration;
        }

        foreach (var p in info.PropertiesToImplement)
        {
            var propertyDeclaration = CreateFromInfo(p)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)));
            propertyDeclarations.Add(propertyDeclaration);
        }

        foreach (var p in info.OverloadedPropertiesToImplement)
        {
            var explicitInterfaceSpecifier = ExplicitInterfaceSpecifier(
                IdentifierName(p.InterfaceNameForExplicitImpl));
            var propertyDeclaration = CreateFromInfo(p.Property)
                .WithExplicitInterfaceSpecifier(explicitInterfaceSpecifier);
            propertyDeclarations.Add(propertyDeclaration);
        }

        var members = propertyDeclarations.ToArray();
        var result = info.Hierarchy.GetSyntax(members);
        return result;
    }
}